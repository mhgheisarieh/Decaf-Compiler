import java_cup.runtime.*;
import ast.*;

parser code {:

     protected RootNode root;

     void setRoot(RootNode p) { this.root = p; }

     public RootNode getRoot() { return this.root; }

:}

/*reserved*/
// Types
terminal VOID, INT, DOUBLE, BOOL, STRING;
// Boolean
terminal Boolean T_BOOLEANLITERAL;
// Other reserved
terminal CLASS, INTERFACE, NULL, THIS, EXTENDS, IMPLEMENTS, FOR, WHILE, IF, ELSE, RETURN, BREAK, CONTINUE, NEW, NEWARRAY, PRINT, READINTEGER, READLINE, DTOI, ITOD, BTOI, ITOB, PRIVATE, PROTECTED, PUBLIC;

/* identifiers */
terminal String T_ID;

/* literals */
terminal Integer T_INTLITERAL;
terminal Double T_DOUBLELITERAL;
terminal String T_STRINGLITERAL;

/* operators */
terminal ASSIGN, EQ, PLUS;

/* punctuations */
terminal MINUS, PROD, DIV, MOD, LESS, LESSEQ, GT, GTEQ, NOTEQ, NOT, AND, OR, SEMI, COMMA, DOT, LBRACK, BRACK, RBRACK, LPAREN, RPAREN, OPENAC, CLOSEAC;

non terminal Node Initial;
non terminal Node Program;
non terminal Node Decl;
non terminal Node VariableDecl,Variable;
non terminal Node Type;
non terminal Node FunctionDecl;
non terminal Node Formals,TempFormals;
non terminal Node ClassDecl;
non terminal Node Extends;
non terminal Node Field;
non terminal Node Fields;
non terminal Node StmtBlock;
non terminal Node VarDecls;
non terminal Node Stmts;
non terminal Node Stmt;
non terminal Node WhileStmt;
non terminal Node ForStmt;
non terminal Node ReturnStmt;
non terminal Node BreakStmt;
non terminal Node PrintStmt;
non terminal Node Expr;
non terminal Node LValue;
non terminal Node Call;
non terminal Node Actuals;
non terminal Node Constant;
non terminal Node Exprs;
non terminal Node ExprOrNot;
// Matin
nonterminal Node InterfaceDecl;
nonterminal Node Implements, TempImplements;
nonterminal Node AccessMode;
nonterminal Node ProtoTypes, ProtoType;
nonterminal Node IfStmt, ContinueStmt;

//precedence of operators
precedence left ELSE;
precedence left ASSIGN;
precedence left OR;
precedence left AND;
precedence left EQ, NOTEQ;
precedence left LESS, LESSEQ, GT, GTEQ;
precedence left PLUS, MINUS;
precedence left PROD, DIV, MOD;
precedence left NOT;
precedence left DOT, LBRACK;
precedence left LPAREN;

// grammar
start with Program;

Program      ::=  Decl:d
                    {:
                        RESULT = new RootNode();
                        RESULT.addChild(d);
                        setRoot((RootNode) RESULT);
                    :}
                | Program:p Decl:d
                    {:
                        RESULT = p;
                        RESULT.addChild(d);
                    :}
                ;

Decl         ::= VariableDecl:t
                    {: RESULT = t; :}
                | FunctionDecl:t
                    {: RESULT = t; :}
                | ClassDecl:t
                    {: RESULT = t; :}
                | InterfaceDecl:t
                    {: RESULT = t; :}
                ;

VariableDecl ::= Variable:v SEMI
                     {: RESULT = v; :}
                     ;

Variable     ::= Type:t T_ID:i
                     {:
                        RESULT = new SimpleNode(NodeType.VARIABLE_DECLARATION);
                        RESULT.addChild(t);
                        RESULT.addChild(i);
                        t.setParent(RESULT);
                        i.setParent(RESULT);
                     :};

Type         ::= INT
                    {: RESULT = new PrimitiveNode(NodeType.INT_TYPE, PrimitiveType.INT); :}
                | DOUBLE
                    {: RESULT = new PrimitiveNode(NodeType.DOUBLE_TYPE, PrimitiveType.DOUBLE); :}
                | BOOL
                    {: RESULT = new PrimitiveNode(NodeType.BOOLEAN_TYPE, PrimitiveType.BOOL); :}
                | STRING
                    {: RESULT = new PrimitiveNode(NodeType.STRING_TYPE, PrimitiveType.STRING); :}
                | T_ID:i
                    {: RESULT = i; :}
                | Type BRACK
                    //TODO
                ; //We use Brack insted of LBRACK RBRACK because of Reduce/Reduce conflict

FunctionDecl ::= Type:t T_ID:i LPAREN Formals:f RPAREN StmtBlock:s
                    {:
                        RESULT = new SimpleNode(NodeType.METHOD_DECLARATION);
                        RESULT.addChild(t, i, f, s);
                        t.setParent(RESULT);
                        i.setParent(RESULT);
                        f.setParent(RESULT);
                        s.setParent(RESULT);
                    :}
               | VOID T_ID:i LPAREN Formals:f RPAREN StmtBlock:s
                    {:
                        RESULT = new SimpleNode(NodeType.METHOD_DECLARATION);
                        RESULT.addChild(t, i, f, s);
                        t.setParent(RESULT);
                        i.setParent(RESULT);
                        f.setParent(RESULT);
                        s.setParent(RESULT);
                    :}
               ;

Formals      ::= TempFormals:t
                    {: RESULT = t; :}
               | /*epsilon*/
                    {: RESULT = new EmptyNode(); :}
               ;
TempFormals  ::=  Variable:v
                    {:
                        RESULT = new SimpleNode(NodeType.ARGUMENTS);
                        ASTNode a = new SimpleNode(NodeType.ARGUMENT);
                        RESULT.addChild(a);
                        a.setParent(RESULT);
                        a.addChild(v);
                        v.setParent(a);
                    :}
               | TempFormals:t COMMA Variable:v
                    {:
                        RESULT = t;
                        ASTNode a = new SimpleNode(NodeType.ARGUMENT);
                        RESULT.addChild(a);
                        a.setParent(RESULT);
                        a.addChild(v);
                        v.setParent(a);
                    :}
               ;

ClassDecl    ::= CLASS T_ID Extends Implements OPENAC Fields CLOSEAC
                    //TODO
               ;
Extends      ::= EXTENDS T_ID
                    //TODO
               | /*epsilon*/
                    {: RESULT = new EmptyNode(); :}
               ;
Implements   ::= IMPLEMENTS TempImplements
                    //TODO
               ;
TempImplements ::= T_ID
                    //TODO
               | TempImplements COMMA T_ID
                    //TODO
               ;
Fields       ::= Fields Field
                    //TODO
               | /*epsilon*/
                    {: RESULT = new EmptyNode(); :}
               ;

Field        ::= AccessMode VariableDecl  | AccessMode FunctionDecl ;

AccessMode   ::= PRIVATE | PROTECTED | PUBLIC | /*epsilon*/ ;

InterfaceDecl::= INTERFACE T_ID OPENAC ProtoTypes CLOSEAC;
ProtoTypes   ::= ProtoTypes ProtoType | /*epsilon*/ ;

ProtoType    ::= Type T_ID LPAREN Formals RPAREN SEMI
               | VOID T_ID LPAREN Formals RPAREN SEMI;

StmtBlock    ::= OPENAC VarDecls Stmts CLOSEAC ;
VarDecls     ::= VarDecls VariableDecl  | /*epsilon*/ ;
Stmts        ::= Stmt Stmts | /*epsilon*/ ;

Stmt         ::= Expr SEMI | /*epsilon*/ SEMI
               | IfStmt
               | WhileStmt
               | ForStmt
               | BreakStmt
               | ContinueStmt
               | ReturnStmt
               | PrintStmt
               | StmtBlock;

IfStmt       ::= IF LPAREN Expr RPAREN Stmt
               | IF LPAREN Expr RPAREN Stmt ELSE Stmt;

WhileStmt    ::= WHILE LPAREN Expr RPAREN Stmt ;

ForStmt      ::= FOR LPAREN ExprOrNot SEMI Expr SEMI ExprOrNot RPAREN Stmt ;
ExprOrNot    ::= Expr  | /*epsilon*/ ;

ReturnStmt   ::= RETURN ExprOrNot SEMI ;

BreakStmt    ::= BREAK SEMI ;

ContinueStmt ::= CONTINUE SEMI;

PrintStmt    ::=    PRINT LPAREN Exprs RPAREN SEMI ;
Exprs        ::=    Expr
               |    Exprs COMMA Expr ;

Expr         ::=    LValue ASSIGN Expr
               |    Constant
               |    LValue
               |    THIS
               |    Call
               |    LPAREN Expr RPAREN
               |    Expr PLUS Expr
               |    Expr MINUS Expr
               |    Expr PROD Expr
               |    Expr DIV Expr
               |    Expr MOD Expr
               |    MINUS Expr
               |    Expr LESS Expr
               |    Expr LESSEQ Expr
               |    Expr GT Expr
               |    Expr GTEQ Expr
               |    Expr EQ Expr
               |    Expr NOTEQ Expr
               |    Expr AND Expr
               |    Expr OR Expr
               |    NOT Expr
               |    READINTEGER LPAREN RPAREN
               |    READLINE LPAREN RPAREN
               |    NEW T_ID
               |    NEWARRAY LPAREN Expr COMMA Type RPAREN
               |    ITOD LPAREN Expr RPAREN
               |    DTOI LPAREN Expr RPAREN
               |    ITOB LPAREN Expr RPAREN
               |    BTOI LPAREN Expr RPAREN;

LValue       ::=    T_ID
               |    Expr DOT T_ID
               |    Expr LBRACK Expr RBRACK ;

Call         ::=    T_ID LPAREN Actuals RPAREN
               |    Expr DOT T_ID LPAREN Actuals RPAREN ;

Actuals      ::=    Exprs | /*epsilon*/ ;

Constant    ::=    T_INTLITERAL:t
                        {: RESULT = new IntegerLiteralNode(t); :}
               |   T_DOUBLELITERAL:t
                        {: RESULT = new DoubleLiteralNode(t); :}
               |   T_BOOLEANLITERAL:t
                        {: RESULT = new BooleanLiteralNode(t); :}
               |   T_STRINGLITERAL:t
                        {: RESULT = new StringLiteralNode(t); :}
               |   NULL
                        {: RESULT = new SimpleNode(NodeType.NULL_LITERAL); :}
               ;