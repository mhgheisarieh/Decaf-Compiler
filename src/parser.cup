import java_cup.runtime.*;
import ast.*;

parser code {:

     protected RootNode root;

     void setRoot(RootNode p) { this.root = p; }

     public RootNode getRoot() { return this.root; }

:}

/*reserved*/
// Types
terminal VOID, INT, DOUBLE, BOOL, STRING;
// Boolean
terminal Boolean T_BOOLEANLITERAL;
// Other reserved
terminal CLASS, INTERFACE, NULL, THIS, EXTENDS, IMPLEMENTS, FOR, WHILE, IF, ELSE, RETURN, BREAK, CONTINUE, NEW, NEWARRAY, PRINT, READINTEGER, READLINE, DTOI, ITOD, BTOI, ITOB, PRIVATE, PROTECTED, PUBLIC;

/* identifiers */
terminal String T_ID;

/* literals */
terminal Integer T_INTLITERAL;
terminal Double T_DOUBLELITERAL;
terminal String T_STRINGLITERAL;

/* operators */
terminal ASSIGN, EQ, PLUS;

/* punctuations */
terminal MINUS, PROD, DIV, MOD, LESS, LESSEQ, GT, GTEQ, NOTEQ, NOT, AND, OR, SEMI, COMMA, DOT, LBRACK, BRACK, RBRACK, LPAREN, RPAREN, OPENAC, CLOSEAC;

non terminal Node Initial;
non terminal Node Program;
non terminal Node Decl;
non terminal Node VariableDecl,Variable;
non terminal Node Type;
non terminal Node FunctionDecl;
non terminal Node Formals,TempFormals;
non terminal Node ClassDecl;
non terminal Node Extends;
non terminal Node Field;
non terminal Node Fields;
non terminal Node StmtBlock;
non terminal Node VarDecls;
non terminal Node Stmts;
non terminal Node Stmt;
non terminal Node WhileStmt;
non terminal Node ForStmt;
non terminal Node ReturnStmt;
non terminal Node BreakStmt;
non terminal Node PrintStmt;
non terminal Node Expr;
non terminal Node LValue;
non terminal Node Call;
non terminal Node Actuals;
non terminal Node Constant;
non terminal Node Exprs;
non terminal Node ExprOrNot;
// Matin
nonterminal Node InterfaceDecl;
nonterminal Node Implements, TempImplements;
nonterminal Node AccessMode;
nonterminal Node ProtoTypes, ProtoType;
nonterminal Node IfStmt, ContinueStmt;

//precedence of operators
precedence left ELSE;
precedence left ASSIGN;
precedence left OR;
precedence left AND;
precedence left EQ, NOTEQ;
precedence left LESS, LESSEQ, GT, GTEQ;
precedence left PLUS, MINUS;
precedence left PROD, DIV, MOD;
precedence left NOT;
precedence left DOT, LBRACK;
precedence left LPAREN;

// grammar

Initial      ::= Program;

Program      ::=  Decl
                | Program Decl;

Decl         ::= VariableDecl | FunctionDecl | ClassDecl | InterfaceDecl;

VariableDecl ::= Variable SEMI;

Variable     ::= Type T_ID;

Type         ::= INT | DOUBLE | BOOL | STRING | T_ID | Type BRACK; //We use Brack insted of LBRACK RBRACK because of Reduce/Reduce conflict

FunctionDecl ::= Type T_ID LPAREN Formals RPAREN StmtBlock
               | VOID T_ID LPAREN Formals RPAREN StmtBlock ;

Formals      ::= TempFormals  | /*epsilon*/ ;
TempFormals  ::=  Variable  |
                  TempFormals COMMA Variable ;

ClassDecl    ::= CLASS T_ID Extends Implements OPENAC Fields CLOSEAC ;
Extends      ::= EXTENDS T_ID  | /*epsilon*/ ;
Implements   ::= IMPLEMENTS TempImplements;
TempImplements ::= T_ID |
                   TempImplements COMMA T_ID;
Fields       ::= Fields Field | /*epsilon*/ ;

Field        ::= AccessMode VariableDecl  | AccessMode FunctionDecl ;

AccessMode   ::= PRIVATE | PROTECTED | PUBLIC | /*epsilon*/ ;

InterfaceDecl::= INTERFACE T_ID OPENAC ProtoTypes CLOSEAC;
ProtoTypes   ::= ProtoTypes ProtoType | /*epsilon*/ ;

ProtoType    ::= Type T_ID LPAREN Formals RPAREN SEMI
               | VOID T_ID LPAREN Formals RPAREN SEMI;

StmtBlock    ::= OPENAC VarDecls Stmts CLOSEAC ;
VarDecls     ::= VarDecls VariableDecl  | /*epsilon*/ ;
Stmts        ::= Stmt Stmts | /*epsilon*/ ;

Stmt         ::= Expr SEMI | /*epsilon*/ SEMI
               | IfStmt
               | WhileStmt
               | ForStmt
               | BreakStmt
               | ContinueStmt
               | ReturnStmt
               | PrintStmt
               | StmtBlock;

IfStmt       ::= IF LPAREN Expr RPAREN Stmt
               | IF LPAREN Expr RPAREN Stmt ELSE Stmt;

WhileStmt    ::= WHILE LPAREN Expr RPAREN Stmt ;

ForStmt      ::= FOR LPAREN ExprOrNot SEMI Expr SEMI ExprOrNot RPAREN Stmt ;
ExprOrNot    ::= Expr  | /*epsilon*/ ;

ReturnStmt   ::= RETURN ExprOrNot SEMI ;

BreakStmt    ::= BREAK SEMI ;

ContinueStmt ::= CONTINUE SEMI;

PrintStmt    ::=    PRINT LPAREN Exprs RPAREN SEMI ;
Exprs        ::=    Expr
               |    Exprs COMMA Expr ;

Expr         ::=    LValue ASSIGN Expr
               |    Constant
               |    LValue
               |    THIS
               |    Call
               |    LPAREN Expr RPAREN
               |    Expr PLUS Expr
               |    Expr MINUS Expr
               |    Expr PROD Expr
               |    Expr DIV Expr
               |    Expr MOD Expr
               |    MINUS Expr
               |    Expr LESS Expr
               |    Expr LESSEQ Expr
               |    Expr GT Expr
               |    Expr GTEQ Expr
               |    Expr EQ Expr
               |    Expr NOTEQ Expr
               |    Expr AND Expr
               |    Expr OR Expr
               |    NOT Expr
               |    READINTEGER LPAREN RPAREN
               |    READLINE LPAREN RPAREN
               |    NEW T_ID
               |    NEWARRAY LPAREN Expr COMMA Type RPAREN
               |    ITOD LPAREN Expr RPAREN
               |    DTOI LPAREN Expr RPAREN
               |    ITOB LPAREN Expr RPAREN
               |    BTOI LPAREN Expr RPAREN;

LValue       ::=    T_ID
               |    Expr DOT T_ID
               |    Expr LBRACK Expr RBRACK ;

Call         ::=    T_ID LPAREN Actuals RPAREN
               |    Expr DOT T_ID LPAREN Actuals RPAREN ;

Actuals      ::=    Exprs | /*epsilon*/ ;

Constant    ::=    T_INTLITERAL
               |   T_DOUBLELITERAL
               |   T_BOOLEANLITERAL
               |   T_STRINGLITERAL
               |   NULL ;